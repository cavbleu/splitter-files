### **Как программа находит и извлекает файлы из бинарных данных**

Программа использует **сигнатуры (магические числа)** файлов и дополнительные проверки структуры, чтобы определить начало и конец файла. Вот как это работает:

---

## **1. Поиск начала файла**
Программа ищет **уникальные последовательности байтов** (магические числа), которые указывают на начало файла определенного формата.

### **Примеры сигнатур:**
| Формат  | Сигнатура (HEX)                     | Описание                     |
|---------|------------------------------------|-----------------------------|
| **PDF** | `25 50 44 46` (`%PDF`)             | Первые 4 байта PDF-файла    |
| **ZIP** | `50 4B 03 04` (`PK..`)             | Сигнатура ZIP-архива        |
| **JPEG**| `FF D8 FF`                         | Начало JPEG-изображения     |
| **DOCX**| `50 4B 03 04` + проверка структуры | ZIP-контейнер + файлы Word  |

### **Как это работает:**
1. Программа сканирует данные побайтово.
2. При обнаружении сигнатуры (например, `%PDF`) проверяется:
   - **Валидность** (например, для PDF проверяется версия `%PDF-1.7`).
   - **Структура файла** (например, наличие `xref` и `%%EOF` в PDF).

---

## **2. Определение конца файла**
После нахождения начала программа ищет **маркеры конца файла** или **следующую сигнатуру**.

### **Способы определения конца:**
#### **A. Фиксированные маркеры конца**
Некоторые форматы имеют четкие маркеры окончания:
- **JPEG**: `FF D9` (конец изображения).
- **PDF**: `%%EOF` (но требуется дополнительная проверка структуры).

#### **B. Структурный анализ**
Для сложных форматов (PDF, DOCX) проверяется **корректность структуры**:
- **PDF**:
  - Должен содержать `xref` (таблица объектов).
  - Должен заканчиваться на `%%EOF` (но иногда встречаются "лишние" байты после).
  - Проверяется наличие `startxref` перед `%%EOF`.

- **ZIP/DOCX/XLSX**:
  - Ищется `50 4B 05 06` (сигнатура конца ZIP-архива).
  - Проверяется целостность внутренней структуры (например, наличие `[Content_Types].xml` в DOCX).

#### **C. Поиск следующей сигнатуры**
Если файл не имеет четкого маркера конца, программа:
1. Ищет **следующую сигнатуру** (например, после PDF может идти JPEG).
2. Если найдена новая сигнатура, конец предыдущего файла устанавливается **перед ней**.

---

## **3. Валидация файла**
Не все файлы с правильной сигнатурой являются валидными. Поэтому программа дополнительно проверяет:
- **Для PDF**:
  ```go
  if !bytes.Contains(data, []byte("xref")) || !bytes.Contains(data, []byte("%%EOF")) {
      return false // Невалидный PDF
  }
  ```
- **Для JPEG**:
  ```go
  if !bytes.Contains(data, []byte{0xFF, 0xD9}) {
      return false // Неполное JPEG
  }
  ```
- **Для ZIP/DOCX**:
  ```go
  if !bytes.Contains(data, []byte{0x50, 0x4B, 0x05, 0x06}) {
      return false // Поврежденный ZIP
  }
  ```

---

## **4. Что происходит, если файл поврежден?**
- Если **конец файла не найден**, программа может:
  - Извлечь файл до следующей сигнатуры (возможно, неполный).
  - Пропустить файл, если он слишком мал (менее 2 КБ по умолчанию).

- Если **начало найдено, но структура нарушена**, файл помечается как **возможно поврежденный**.

---

## **5. Пример работы на практике**
**Допустим, у нас есть бинарный дамп:**
```
[Некоторые данные][%PDF-1.4 ... xref ... %%EOF][FF D8 FF ... FF D9][50 4B 03 04 ... 50 4B 05 06]
```
1. Программа находит `%PDF` → проверяет наличие `xref` и `%%EOF` → извлекает PDF.
2. Далее находит `FF D8 FF` → ищет `FF D9` → извлекает JPEG.
3. Затем находит `50 4B 03 04` → проверяет конец архива `50 4B 05 06` → извлекает ZIP.

---

## **Вывод**
Программа **не** использует сложные эвристические методы, а полагается на:
1. **Сигнатуры начала файла**.
2. **Структурные маркеры конца**.
3. **Валидацию формата**.

Это позволяет эффективно восстанавливать **целые файлы**, но **не гарантирует** работоспособность поврежденных данных внутри них. Для сложных случаев (например, перезаписанные PDF) могут потребоваться специализированные инструменты

